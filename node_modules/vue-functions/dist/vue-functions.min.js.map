{"version":3,"file":"vue-functions.min.js","sources":["../node_modules/helper-js/dist/helper-js.esm.js","../src/index.js"],"sourcesContent":["/*!\n* helper-js v1.4.14\n* (c) phphe <phphe@outlook.com> (https://github.com/phphe)\n* Released under the MIT License.\n*/\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar _marked =\n/*#__PURE__*/\nregeneratorRuntime.mark(iterateALL);\n\n// local store\nvar store = {}; // get global\n// `this` !== global or window because of build tool\n\nfunction glb() {\n  if (store.glb) {\n    return store.glb;\n  } else {\n    // resolve global\n    var t;\n\n    try {\n      t = global;\n    } catch (e) {\n      t = window;\n    }\n\n    store.glb = t;\n    return t;\n  }\n} // is 各种判断\n\nfunction isset(v) {\n  return typeof v !== 'undefined';\n}\nfunction isArray(v) {\n  return Object.prototype.toString.call(v) === '[object Array]';\n}\nfunction isBool(v) {\n  return Object.prototype.toString.call(v) === '[object Boolean]';\n}\nfunction isNumber(v) {\n  return Object.prototype.toString.call(v) === '[object Number]';\n}\nfunction isNumeric(v) {\n  return isFinite(v) && !isNaN(parseFloat(v));\n}\nfunction isString(v) {\n  return Object.prototype.toString.call(v) === '[object String]';\n}\nfunction isObject(v) {\n  return Object.prototype.toString.call(v) === '[object Object]';\n}\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\nfunction isPromise(v) {\n  return Object.prototype.toString.call(v) === '[object Promise]';\n}\nfunction empty(v) {\n  if (v == null) {\n    return true;\n  } else if (v.length != null) {\n    return v.length === 0;\n  } else if (isBool(v)) {\n    return false;\n  } else if (isNumber(v)) {\n    return isNaN(v);\n  } else if (isObject(v)) {\n    return Object.keys(v).length === 0;\n  }\n} // num\n\nfunction numRand(min, max) {\n  if (arguments.length === 1) {\n    max = min;\n    min = 0;\n  }\n\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\nfunction numPad(num, n) {\n  var len = num.toString().length;\n\n  while (len < n) {\n    num = '0' + num;\n    len++;\n  }\n\n  return num;\n}\nfunction min(n, min) {\n  return n < min ? min : n;\n}\nfunction max(n, max) {\n  return n < max ? n : max;\n} // str 字符\n\nfunction studlyCase(str) {\n  return str && str[0].toUpperCase() + str.substr(1);\n}\nfunction kebabCase(str) {\n  return str.replace(/ /g, '-').replace(/_/g, '-').replace(/([A-Z])/g, '-$1').replace(/--+/g, '-').replace(/^-|-$|/g, '').toLowerCase();\n}\nfunction snakeCase(str) {\n  return kebabCase(str).replace(/-/g, '_');\n}\nfunction camelCase(str) {\n  var temp = str.toString().split(/[-_]/);\n\n  for (var i = 1; i < temp.length; i++) {\n    temp[i] = studlyCase(temp[i]);\n  }\n\n  return temp.join('');\n}\nfunction camelToWords(str) {\n  return str.toString().trim().split(/(?=[A-Z])/);\n}\nfunction titleCase(str) {\n  return camelToWords(studlyCase(camelCase(str))).join(' ').replace(/\\bid\\b/ig, 'ID');\n}\nfunction strRand() {\n  var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var r = '';\n  var seeds = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n  for (var i = 0; i < len; i++) {\n    r += seeds[numRand(seeds.length - 1)];\n  }\n\n  return prefix + r;\n}\nfunction replaceMultiple(mapObj, str) {\n  var reg = new RegExp(Object.keys(mapObj).join('|'), 'g');\n  return str.replace(reg, function (matchedKey) {\n    return mapObj[matchedKey];\n  });\n} // array\n\nfunction arrayRemove(arr, v) {\n  var index;\n  var count = 0;\n\n  while ((index = arr.indexOf(v)) > -1) {\n    arr.splice(index, 1);\n    count++;\n  }\n\n  return count;\n}\nfunction arrayRemoveBySortedIndexes(arr, sortedIndexes) {\n  for (var i = sortedIndexes.length - 1; i >= 0; i--) {\n    var index = sortedIndexes[i];\n    arr.splice(index, 1);\n  }\n}\nfunction newArrayRemoveAt(arr, indexes) {\n  indexes = toArrayIfNot(indexes);\n  var mapping = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = indexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var index = _step.value;\n      mapping[index] = true;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var newArr = [];\n  var len = arr.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!mapping[i]) {\n      newArr.push(arr[i]);\n    }\n  }\n\n  return newArr;\n}\nfunction arrayAt(arr, n) {\n  return arr[n >= 0 ? n : arr.length + n];\n}\nfunction arrayFirst(arr) {\n  return arr[0];\n}\nfunction arrayLast(arr) {\n  return arr[arr.length - 1];\n}\nfunction arrayDiff(arr1, arr2) {\n  var len = arr1.length;\n  var arr = [];\n\n  while (len--) {\n    if (arr2.indexOf(arr1[len]) < 0) {\n      arr.push(arr1[len]);\n    }\n  }\n\n  return arr;\n} // offset can be many\n\nfunction arraySibling(arr, item, offset) {\n  var index = arr.indexOf(item);\n\n  if (index === -1) {\n    throw 'item is not in array';\n  }\n\n  if (isArray(offset)) {\n    return offset.map(function (v) {\n      return arr[index + v];\n    });\n  }\n\n  return arr[index + offset];\n}\nfunction toArrayIfNot(arrOrNot) {\n  return isArray(arrOrNot) ? arrOrNot : [arrOrNot];\n} // n can be getter(number of times)\n// n可以是方法, 参数1是第几次分块\n\nfunction splitArray(arr, n) {\n  var r = [];\n\n  if (isFunction(n)) {\n    var getChunkLength = n;\n    var times = 1;\n    var i = 0;\n\n    while (i < arr.length) {\n      var _n = getChunkLength(times);\n\n      var end = i + _n;\n      r.push(arr.slice(i, end));\n      i = end;\n      times++;\n    }\n  } else {\n    var _i = 0;\n\n    while (_i < arr.length) {\n      var _end = _i + n;\n\n      r.push(arr.slice(_i, _end));\n      _i = _end;\n    }\n  }\n\n  return r;\n}\nfunction groupArray(arr, getMark) {\n  var groups = new Map();\n  arr.forEach(function (v) {\n    var mark = getMark(v);\n\n    if (!groups.has(mark)) {\n      groups.set(mark, []);\n    }\n\n    groups.get(mark).push(v);\n  });\n  var r = [];\n  groups.forEach(function (value, key) {\n    r.push([key, value]);\n  });\n  return r;\n}\nfunction arrayDistinct(arr) {\n  if (glb().Set) {\n    return _toConsumableArray(new Set(arr));\n  } else {\n    return arr.filter(function (v, i, a) {\n      return a.indexOf(v) === i;\n    });\n  }\n}\nfunction arrayGet(arr, index, endIndex) {\n  if (index < 0) {\n    index += arr.length;\n  }\n\n  if (endIndex == null) {\n    return arr[index];\n  } else {\n    if (endIndex < 0) {\n      endIndex += arr.length;\n    }\n\n    return arr.slice(index, endIndex - index + 1);\n  }\n}\nfunction arrayWithoutEnd(arr, len) {\n  return arr.slice(0, arr.length - len);\n} // object\n\nfunction assignIfDifferent(obj, key, val) {\n  if (obj[key] !== val) {\n    obj[key] = val;\n  }\n}\nfunction objectMerge(o1, o2) {\n  for (var k in o2) {\n    if (!o1.hasOwnProperty(k)) {\n      o1[k] = o2[k];\n    } else if (isObject(o1[k]) && isObject(o2[k])) {\n      Object.assign(o1[k], o2[k]);\n    } else {\n      o1[k] = o2[k];\n    }\n  }\n\n  return o1;\n}\nfunction objectMap(obj, func) {\n  var r = {};\n\n  for (var key in obj) {\n    r[key] = func(obj[key], key, obj);\n  }\n\n  return r;\n}\nfunction objectOnly(obj, keys) {\n  var r = {};\n\n  for (var key in obj) {\n    if (keys.indexOf(key) > -1) {\n      r[key] = obj[key];\n    }\n  }\n\n  return r;\n}\nfunction objectExcept(obj, keys) {\n  var r = {};\n\n  for (var key in obj) {\n    if (keys.indexOf(key) === -1) {\n      r[key] = obj[key];\n    }\n  }\n\n  return r;\n} // loop for all type\n// todo change reverse to opt in next version\n\nfunction forAll(val, handler, reverse) {\n  if (!reverse) {\n    if (isArray(val) || isString(val) || val.hasOwnProperty('length')) {\n      for (var i = 0; i < val.length; i++) {\n        if (handler(val[i], i) === false) {\n          break;\n        }\n      }\n    } else if (isObject(val)) {\n      for (var _i2 = 0, _Object$keys = Object.keys(val); _i2 < _Object$keys.length; _i2++) {\n        var key = _Object$keys[_i2];\n\n        if (handler(val[key], key) === false) {\n          break;\n        }\n      }\n    } else if (Number.isInteger(val)) {\n      for (var _i3 = 0; _i3 < val; _i3++) {\n        if (handler(_i3, _i3) === false) {\n          break;\n        }\n      }\n    }\n  } else {\n    if (isArray(val) || isString(val) || val.hasOwnProperty('length')) {\n      for (var _i4 = val.length - 1; _i4 >= 0; _i4--) {\n        if (handler(val[_i4], _i4) === false) {\n          break;\n        }\n      }\n    } else if (isObject(val)) {\n      var keys = Object.keys(val);\n      keys.reverse();\n\n      for (var _i5 = 0, _keys = keys; _i5 < _keys.length; _i5++) {\n        var _key = _keys[_i5];\n\n        if (handler(val[_key], _key) === false) {\n          break;\n        }\n      }\n    } else if (Number.isInteger(val)) {\n      for (var _i6 = val - 1; _i6 >= 0; _i6--) {\n        if (handler(_i6, _i6) === false) {\n          break;\n        }\n      }\n    }\n  }\n} // loop for Array, Object, NodeList, String\n\nfunction iterateALL(val) {\n  var opt,\n      i,\n      info,\n      _i7,\n      _Object$keys2,\n      key,\n      _info,\n      _i8,\n      _info2,\n      keys,\n      _i9,\n      _keys2,\n      _key2,\n      _info3,\n      _args = arguments;\n\n  return regeneratorRuntime.wrap(function iterateALL$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          opt = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n          if (opt.reverse) {\n            _context.next = 30;\n            break;\n          }\n\n          if (!(val.length != null)) {\n            _context.next = 14;\n            break;\n          }\n\n          i = 0;\n\n        case 4:\n          if (!(i < val.length)) {\n            _context.next = 12;\n            break;\n          }\n\n          info = {\n            value: val[i],\n            index: i\n          };\n\n          if (!(!opt.exclude || !opt.exclude(info))) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return info;\n\n        case 9:\n          i++;\n          _context.next = 4;\n          break;\n\n        case 12:\n          _context.next = 28;\n          break;\n\n        case 14:\n          if (!isObject(val)) {\n            _context.next = 27;\n            break;\n          }\n\n          _i7 = 0, _Object$keys2 = Object.keys(val);\n\n        case 16:\n          if (!(_i7 < _Object$keys2.length)) {\n            _context.next = 25;\n            break;\n          }\n\n          key = _Object$keys2[_i7];\n          _info = {\n            value: val[key],\n            key: key\n          };\n\n          if (!(!opt.exclude || !opt.exclude(_info))) {\n            _context.next = 22;\n            break;\n          }\n\n          _context.next = 22;\n          return _info;\n\n        case 22:\n          _i7++;\n          _context.next = 16;\n          break;\n\n        case 25:\n          _context.next = 28;\n          break;\n\n        case 27:\n          throw 'Unsupported type';\n\n        case 28:\n          _context.next = 58;\n          break;\n\n        case 30:\n          if (!(val.length != null)) {\n            _context.next = 42;\n            break;\n          }\n\n          _i8 = val.length - 1;\n\n        case 32:\n          if (!(_i8 >= 0)) {\n            _context.next = 40;\n            break;\n          }\n\n          _info2 = {\n            value: val[_i8],\n            index: _i8\n          };\n\n          if (!(!opt.exclude || !opt.exclude(_info2))) {\n            _context.next = 37;\n            break;\n          }\n\n          _context.next = 37;\n          return _info2;\n\n        case 37:\n          _i8--;\n          _context.next = 32;\n          break;\n\n        case 40:\n          _context.next = 58;\n          break;\n\n        case 42:\n          if (!isObject(val)) {\n            _context.next = 57;\n            break;\n          }\n\n          keys = Object.keys(val);\n          keys.reverse();\n          _i9 = 0, _keys2 = keys;\n\n        case 46:\n          if (!(_i9 < _keys2.length)) {\n            _context.next = 55;\n            break;\n          }\n\n          _key2 = _keys2[_i9];\n          _info3 = {\n            value: val[_key2],\n            key: _key2\n          };\n\n          if (!(!opt.exclude || !opt.exclude(_info3))) {\n            _context.next = 52;\n            break;\n          }\n\n          _context.next = 52;\n          return _info3;\n\n        case 52:\n          _i9++;\n          _context.next = 46;\n          break;\n\n        case 55:\n          _context.next = 58;\n          break;\n\n        case 57:\n          throw 'Unsupported type';\n\n        case 58:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // source: http://stackoverflow.com/questions/8817394/javascript-get-deep-value-from-object-by-passing-path-to-it-as-string\n\nfunction objectGet(obj, path, throwError) {\n  var paths = isArray(path) ? path : path.split('.');\n  var current = obj;\n\n  try {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = paths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var key = _step2.value;\n        current = current[key];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } catch (e) {\n    if (throwError) {\n      throw \"Path does not exist\";\n    }\n  }\n\n  return current;\n}\nfunction objectSet(obj, path, value) {\n  var paths = isArray(path) ? path : path.split('.');\n  var lastKey = arrayLast(paths);\n  var parent = objectGet(obj, paths.slice(0, paths.length - 1));\n\n  if (!parent) {\n    throw \"Path does not exist\";\n  }\n\n  parent[lastKey] = value;\n}\nfunction unset(obj, prop) {\n  obj[prop] = undefined;\n\n  try {\n    delete obj[prop];\n  } catch (e) {}\n} // exclude: array or function\n\nfunction cloneObj(obj, exclude) {\n  var type = _typeof(obj);\n\n  switch (type) {\n    case 'undefined':\n    case 'boolean':\n    case 'nuber':\n    case 'string':\n    case 'function':\n      return obj;\n\n    case 'object':\n      if (obj === null) {\n        // null is object\n        return obj;\n      }\n\n      var r;\n\n      if (isArray(obj)) {\n        r = [];\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = obj[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var item = _step3.value;\n            r.push(cloneObj(item, exclude));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } else {\n        r = {};\n\n        for (var _i10 = 0, _Object$keys3 = Object.keys(obj); _i10 < _Object$keys3.length; _i10++) {\n          var key = _Object$keys3[_i10];\n\n          if (!exclude || isArray(exclude) && !exclude.includes(key) || !exclude(key, obj[key], obj)) {\n            r[key] = cloneObj(obj[key], exclude);\n          }\n        }\n      }\n\n      return r;\n\n    default:\n      return obj;\n  }\n}\n/*\r\nreturn cloned obj\r\nhandler(value, key, parent, newParent)\r\nhandler can return null or an object.\r\nnull: don't change anything\r\nobject{\r\n  key: false, // delete. Deprecated, this will be removed in future, please use `delete` instead of it.\r\n  key: new key, // use a new key instead of old key. if key == null, the old key will be detected\r\n  delete,\r\n  value, // new value. if value not gived, the old value will be detected\r\n  skip, // skip children\r\n  stop,\r\n}\r\n{key: false}: delete\r\n{value}: change value\r\n{key, value}. change key and value\r\nlimit: to prevent circular reference.\r\n */\n\nfunction mapObjectTree(obj, handler) {\n  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  var r;\n  var count = 0;\n  var stack = [{\n    value: obj\n  }];\n\n  var _loop2 = function _loop2() {\n    if (count >= limit) {\n      throw \"mapObjectTree: limit(\".concat(limit, \") reached, object may has circular reference\");\n    }\n\n    count++;\n\n    var _stack$shift = stack.shift(),\n        value = _stack$shift.value,\n        key = _stack$shift.key,\n        parent = _stack$shift.parent,\n        newParent = _stack$shift.newParent;\n\n    var t = handler(value, key, parent, newParent);\n\n    var assign = function assign(value, key, canPush) {\n      if (isArray(value)) {\n        value = [];\n      } else if (isObject(value)) {\n        value = {};\n      }\n\n      if (parent) {\n        if (isArray(newParent) && canPush) {\n          newParent.push(value);\n        } else {\n          newParent[key] = value;\n        }\n      } else {\n        r = value;\n      } // value may changed\n\n\n      return value;\n    };\n\n    var newVal = void 0,\n        val = void 0,\n        toDelete = void 0,\n        stop = void 0,\n        skip = void 0;\n\n    if (!t) {\n      // no change\n      val = value;\n      newVal = assign(value, key);\n    } else {\n      var key2 = t.key,\n          _value = t.value;\n      val = _value;\n\n      if (t[\"delete\"] || key2 === false) {\n        // del\n        toDelete = true;\n      } else if (key2 == null) {\n        // don't change key\n        newVal = assign(_value, key, true);\n      } else if (t.hasOwnProperty('value')) {\n        newVal = assign(_value, key2);\n      }\n\n      stop = t.stop;\n      skip = t.skip;\n    }\n\n    if (toDelete) {\n      return \"continue\";\n    }\n\n    if (skip) {\n      return \"continue\";\n    }\n\n    if (stop) {\n      return \"break\";\n    }\n\n    if (isArray(val)) {\n      var len = val.length;\n\n      for (var i = 0; i < len; i++) {\n        stack.push({\n          value: val[i],\n          key: i,\n          parent: val,\n          newParent: newVal\n        });\n      }\n    } else if (isObject(val)) {\n      Object.keys(val).forEach(function (key) {\n        stack.push({\n          value: val[key],\n          key: key,\n          parent: val,\n          newParent: newVal\n        });\n      });\n    }\n  };\n\n  _loop: while (stack.length > 0) {\n    var _ret = _loop2();\n\n    switch (_ret) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop;\n    }\n  }\n\n  return r;\n} // arr, idKey/getId\n\nfunction mapObjects(arr, idKey) {\n  var r = {};\n  var len = arr.length;\n\n  for (var i = 0; i < len; i++) {\n    var item = arr[i];\n    var id = isFunction(idKey) ? idKey(item, i) : item[idKey];\n    r[id] = item;\n  }\n\n  return r;\n} //\n\nfunction pairRows(rows1, rows2, key1, key2) {\n  if (!key2) {\n    key2 = key1;\n  }\n\n  var map = mapObjects(rows2, key2);\n  return rows1.map(function (row1) {\n    return [row1, map[row1[key1]]];\n  });\n} //\n\nfunction resolveValueOrGettter(valueOrGetter) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (isFunction(valueOrGetter)) {\n    return valueOrGetter.apply(void 0, _toConsumableArray(args));\n  } else {\n    return valueOrGetter;\n  }\n} // function helper | method helper\n\nfunction executeWithCount(func) {\n  var count = 0;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key3 = 0; _key3 < _len; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return func.call.apply(func, [this, count++].concat(args));\n  };\n}\nfunction watchChange(getVal, handler) {\n  var oldVal;\n\n  var update = function update() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var newVal = getVal.apply(void 0, args);\n\n    if (oldVal !== newVal) {\n      handler.apply(void 0, [newVal].concat(args));\n    }\n\n    oldVal = newVal;\n  };\n\n  return update;\n}\nvar store_executeOnceInScopeByName = {};\nfunction executeOnceInScopeByName(name, action) {\n  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scope_executeOnceInScopeByName;\n  var storeResult = arguments.length > 3 ? arguments[3] : undefined;\n  name = \"executeOnceInScopeByName_\".concat(name);\n\n  if (!scope[name]) {\n    var value = action();\n\n    var destroy = function destroy() {\n      delete scope[name];\n    };\n\n    scope[name] = {\n      destroy: destroy\n    };\n\n    if (storeResult) {\n      scope[name].value = value;\n    }\n  }\n\n  return scope[name];\n}\nfunction debounceTrailing(action) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var t;\n  var delaying;\n  var lastArgs; // when trailing, use last args\n\n  var resolves = [];\n  var rejects = [];\n\n  var wrappedAction = function wrappedAction() {\n    var _this = this;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    return new Promise(function (resolve, reject) {\n      resolves.push(resolve);\n      rejects.push(reject); //\n\n      lastArgs = args;\n\n      if (!delaying) {\n        delaying = true;\n        t = setTimeout(function () {\n          var result = action.call.apply(action, [_this].concat(_toConsumableArray(lastArgs)));\n          t = null;\n          delaying = false;\n          resolves.forEach(function (resolve) {\n            return resolve(result);\n          });\n          resolves = [];\n          rejects = [];\n        }, wait);\n      }\n    });\n  };\n\n  wrappedAction.stop = function () {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    delaying = false;\n    resolves = [];\n    rejects.forEach(function (reject) {\n      return reject();\n    });\n    rejects = [];\n  };\n\n  return wrappedAction;\n}\nfunction debounceImmediate(action) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var t;\n  var delaying;\n  var result;\n\n  var wrappedAction = function wrappedAction() {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      if (delaying) {\n        resolve(result);\n      } else {\n        delaying = true;\n        result = action.call.apply(action, [_this2].concat(_toConsumableArray(lastArgs)));\n        resolve(result);\n        t = setTimeout(function () {\n          t = null;\n          delaying = false;\n          result = null;\n        }, wait);\n      }\n    });\n  };\n\n  wrappedAction.stop = function () {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    delaying = false;\n  };\n\n  return wrappedAction;\n}\nfunction debounce(action) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opt.immediate) {\n    return debounceImmediate(action, wait);\n  } else {\n    return debounceTrailing(action, wait);\n  }\n}\n/**\r\n * [joinMethods description]\r\n * @param  {[Function[]]} methods        [description]\r\n * @param  {String} [mode='value'] [value, pipeline]\r\n * @return {[Function]}                [description]\r\n */\n\nfunction joinMethods(methods) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';\n  var simpleJoinedMethod;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    var _loop3 = function _loop3() {\n      var method = _step4.value;\n      var old = simpleJoinedMethod;\n\n      if (old) {\n        simpleJoinedMethod = function simpleJoinedMethod() {\n          for (var _len4 = arguments.length, args = new Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {\n            args[_key6] = arguments[_key6];\n          }\n\n          return method.call.apply(method, [this, mode === 'value' ? old.call.apply(old, [this].concat(args)) : old].concat(args));\n        };\n      } else {\n        simpleJoinedMethod = method;\n      }\n    };\n\n    for (var _iterator4 = methods[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      _loop3();\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n        _iterator4[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return simpleJoinedMethod;\n} // the returned function only accept one argument\n\nfunction joinFunctionsByResult(funcs) {\n  var wrappedFunc = funcs[0];\n\n  for (var i = 1; i < funcs.length; i++) {\n    wrappedFunc = join2func(wrappedFunc, funcs[i]);\n  }\n\n  return wrappedFunc;\n\n  function join2func(func1, func2) {\n    return function (arg) {\n      var result = args;\n      var result1 = func1(arg);\n      return func2(result1);\n    };\n  }\n} // must pass arguments to `next` manually\n\nfunction joinFunctionsByNext(funcs) {\n  var next = function next() {};\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = iterateALL(funcs, {\n      reverse: true\n    })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var func = _step5.value.value;\n      var currentNext = next;\n      next = wrapFuncWithNext(func, currentNext);\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n        _iterator5[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  return next;\n\n  function wrapFuncWithNext(func, next) {\n    return function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return func.apply(void 0, [next].concat(args));\n    };\n  }\n} // promise\n// execute promise in sequence\n\nfunction executePromiseGetters(getters) {\n  var concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var stopped;\n  var promise = new Promise(function (resolve, reject) {\n    var r = [];\n    var chunks = splitArray(getters, concurrent);\n    var promise = Promise.resolve();\n    chunks.forEach(function (chunk) {\n      promise = promise.then(function (result) {\n        if (result) {\n          r.push.apply(r, _toConsumableArray(result));\n        }\n\n        if (stopped) {\n          reject('stopped');\n        } else {\n          return Promise.all(chunk.map(function (v) {\n            return v();\n          }));\n        }\n      });\n    });\n    promise.then(function (result) {\n      r.push.apply(r, _toConsumableArray(result));\n      resolve(r);\n    });\n  });\n  return {\n    promise: promise,\n    destroy: function destroy() {\n      stopped = true;\n    }\n  };\n}\nfunction promiseTimeout(promise, timeout) {\n  return new Promise(function (resolve, reject) {\n    var t, rejected;\n    promise.then(function () {\n      clearTimeout(t);\n      resolve.apply(void 0, arguments);\n    }, function () {\n      if (!rejected) {\n        clearTimeout(t);\n        reject.apply(void 0, arguments);\n      }\n    });\n    t = setTimeout(function () {\n      rejected = true;\n      var e = new Error('Promise timeout!');\n      e.name = 'timeout';\n      reject(e);\n    }, timeout);\n  });\n} // url\n\n/* eslint-disable */\n\nfunction getUrlParam(par) {\n  // 获取当前URL\n  var local_url = document.location.href; // 获取要取得的get参数位置\n\n  var get = local_url.indexOf(par + '=');\n\n  if (get == -1) {\n    return false;\n  } // 截取字符串\n\n\n  var get_par = local_url.slice(par.length + get + 1); // 判断截取后的字符串是否还有其他get参数\n\n  var nextPar = get_par.indexOf('&');\n\n  if (nextPar != -1) {\n    get_par = get_par.slice(0, nextPar);\n  }\n\n  return get_par;\n}\n/* eslint-enable */\n// dom\n\nfunction uniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id_';\n  var id = prefix + strRand();\n  if (!store.uniqueId) store.uniqueId = {};\n  var generatedIds = store.uniqueId;\n\n  if (document.getElementById(id) || generatedIds[id]) {\n    return uniqueId(prefix);\n  } else {\n    generatedIds[id] = true;\n    return id;\n  }\n}\nfunction isDescendantOf(el, parent) {\n  while (true) {\n    if (el.parentElement == null) {\n      return false;\n    } else if (el.parentElement === parent) {\n      return true;\n    } else {\n      el = el.parentElement;\n    }\n  }\n}\nfunction removeEl(el) {\n  if (el.parentNode !== null) {\n    return el.parentNode.removeChild(el);\n  }\n} // refer: https://stackoverflow.com/questions/871399/cross-browser-method-for-detecting-the-scrolltop-of-the-browser-window\n\nfunction getScroll() {\n  if (typeof pageYOffset != 'undefined') {\n    //most browsers except IE before #9\n    return {\n      top: pageYOffset,\n      left: pageXOffset\n    };\n  } else {\n    var B = document.body; //IE 'quirks'\n\n    var D = document.documentElement; //IE with doctype\n\n    D = D.clientHeight ? D : B;\n    return {\n      top: D.scrollTop,\n      left: D.scrollLeft\n    };\n  }\n} // refer: https://gist.github.com/aderaaij/89547e34617b95ac29d1\n\nfunction getOffset(el) {\n  var rect = getBoundingClientRect(el);\n  var scroll = getScroll();\n  return {\n    x: rect.left + scroll.left,\n    y: rect.top + scroll.top\n  };\n} // there is some trap in el.offsetParent, so use this func to fix\n\nfunction getOffsetParent(el) {\n  var offsetParent = el.offsetParent;\n\n  if (!offsetParent || offsetParent === document.body && getComputedStyle(document.body).position === 'static') {\n    offsetParent = document.body.parentElement;\n  }\n\n  return offsetParent;\n} // get el current position. like jQuery.position\n// the position is relative to offsetParent viewport left top. it is for set absolute position, absolute position is relative to offsetParent viewport left top.\n// 相对于offsetParent可视区域左上角(el.offsetLeft或top包含父元素的滚动距离, 所以要减去). position一般用于设置绝对定位的情况, 而绝对定位就是以可视区域左上角为原点.\n\nfunction getPosition(el) {\n  var offsetParent = getOffsetParent(el);\n  var ps = {\n    x: el.offsetLeft,\n    y: el.offsetTop\n  };\n  var parent = el;\n\n  while (true) {\n    parent = parent.parentElement;\n\n    if (parent === offsetParent || !parent) {\n      break;\n    }\n\n    ps.x -= parent.scrollLeft;\n    ps.y -= parent.scrollTop;\n  }\n\n  return ps;\n} // get position of a el if its offset is given. like jQuery.offset.\n// 类似 jQuery.offset的设置功能, 但是它只返回计算的position, 不改变元素样式.\n\nfunction getPositionFromOffset(el, of) {\n  var offsetParent = getOffsetParent(el);\n  var parentOf = getOffset(offsetParent);\n  return {\n    x: of.x - parentOf.x,\n    y: of.y - parentOf.y\n  };\n}\nfunction getBoundingClientRect(el) {\n  // refer: http://www.51xuediannao.com/javascript/getBoundingClientRect.html\n  var xy = el.getBoundingClientRect();\n  var top = xy.top - document.documentElement.clientTop,\n      //document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0\n  bottom = xy.bottom,\n      left = xy.left - document.documentElement.clientLeft,\n      //document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0\n  right = xy.right,\n      width = xy.width || right - left,\n      //IE67不存在width 使用right - left获得\n  height = xy.height || bottom - top;\n  var x = left;\n  var y = top;\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\nvar getViewportPosition = getBoundingClientRect; // todo not tested\n\nfunction viewportPositionToOffset(position) {\n  var body = document.body;\n  var bodyOf = getOffset(body);\n  var bodyVP = getViewportPosition(body);\n  return {\n    x: position.x + bodyOf.x - bodyVP.x,\n    y: position.y + bodyOf.y - bodyVP.y\n  };\n} // todo not tested\n\nfunction offsetToViewportPosition(offset) {\n  var body = document.body;\n  var bodyOf = getOffset(body);\n  var bodyVP = getViewportPosition(body);\n  return {\n    x: offset.x + bodyVP.x - bodyOf.x,\n    y: offset.y + bodyVP.y - bodyOf.y\n  };\n}\nfunction findParent(el, callback, opt) {\n  var cur = opt && opt.withSelf ? el : el.parentElement;\n\n  while (cur) {\n    var r = callback(cur);\n\n    if (r === 'break') {\n      return;\n    } else if (r) {\n      return cur;\n    } else {\n      cur = cur.parentElement;\n    }\n  }\n}\nfunction backupAttr(el, name) {\n  var key = \"original_\".concat(name);\n  el[key] = el.getAttribute(name);\n}\nfunction restoreAttr(el, name) {\n  var key = \"original_\".concat(name);\n  el.setAttribute(name, el[key]);\n} // source: http://youmightnotneedjquery.com/\n\nfunction hasClass(el, className) {\n  if (el.classList) {\n    return el.classList.contains(className);\n  } else {\n    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction addClass(el, className) {\n  if (!hasClass(el, className)) {\n    if (el.classList) {\n      el.classList.add(className);\n    } else {\n      el.className += ' ' + className;\n    }\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction removeClass(el, className) {\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n  }\n} // todo rename to getElSizeEvenInvisible in next version\n\nfunction getElSize(el) {\n  backupAttr(el, 'style');\n  el.style.display = 'block';\n  var t = getBoundingClientRect(el);\n  var size = {\n    width: t.width,\n    height: t.height\n  };\n  restoreAttr(el, 'style');\n  return size;\n}\nvar getElSizeEvenInvisible = getElSize;\n/**\r\n * [isOffsetInEl]\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Object} el HTML Element\r\n */\n\nfunction isOffsetInEl(x, y, el) {\n  var offset = getOffset(el);\n  return offset.x <= x && offset.x + el.offsetWidth >= x && offset.y <= y && offset.y + el.offsetHeight >= y;\n} // get border\n\nfunction getBorder(el) {\n  var body = document.body;\n  var workArea = findParent(el, function (v) {\n    return hasClass(v, 'work-area');\n  });\n  var of = getOffset(workArea);\n  return {\n    left: of.x,\n    right: of.x + workArea.offsetWidth,\n    top: of.y + 50,\n    bottom: body.offsetHeight < glb().innerHeight ? glb().innerHeight : body.offsetHeight\n  };\n}\nfunction setElChildByIndex(el, index, child) {\n  child.childComponentIndex = index;\n  var len = el.childNodes.length;\n\n  if (len === 0) {\n    el.appendChild(child);\n  } else if (index === 0) {\n    el.insertBefore(child, el.childNodes[0]);\n  } else {\n    var _binarySearch = binarySearch(el.childNodes, function (el) {\n      return el.childComponentIndex - index;\n    }, 0, max(index, len - 1), true),\n        nearestIndex = _binarySearch.index,\n        nearest = _binarySearch.value,\n        bigger = _binarySearch.bigger;\n\n    if (bigger) {\n      el.insertBefore(child, nearest);\n    } else {\n      var next = el.childNodes[nearestIndex + 1];\n\n      if (next) {\n        el.insertBefore(child, next);\n      } else {\n        el.appendChild(child);\n      }\n    }\n  }\n} // from https://blog.csdn.net/qq_30100043/article/details/74719534\n\nfunction getCss3Prefix() {\n  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (opt.noCache || store.css3Prefix == null) {\n    store.css3Prefix = reget();\n  }\n\n  return store.css3Prefix;\n\n  function reget() {\n    var div = document.createElement('div');\n    var cssText = '-webkit-transition:all .1s; -moz-transition:all .1s; -o-transition:all .1s; -ms-transition:all .1s; transition:all .1s;';\n    div.style.cssText = cssText;\n    var style = div.style;\n\n    if (style.webkitTransition) {\n      return '-webkit-';\n    }\n\n    if (style.MozTransition) {\n      return '-moz-';\n    }\n\n    if (style.oTransition) {\n      return '-o-';\n    }\n\n    if (style.msTransition) {\n      return '-ms-';\n    }\n\n    return '';\n  }\n} // dom event\n\nfunction onDOM(el, name, handler) {\n  for (var _len6 = arguments.length, args = new Array(_len6 > 3 ? _len6 - 3 : 0), _key8 = 3; _key8 < _len6; _key8++) {\n    args[_key8 - 3] = arguments[_key8];\n  }\n\n  if (el.addEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.addEventListener.apply(el, [name, handler].concat(args));\n  } else if (el.attachEvent) {\n    // IE 8 及更早 IE 版本\n    el.attachEvent.apply(el, [\"on\".concat(name), handler].concat(args));\n  }\n}\nfunction offDOM(el, name, handler) {\n  for (var _len7 = arguments.length, args = new Array(_len7 > 3 ? _len7 - 3 : 0), _key9 = 3; _key9 < _len7; _key9++) {\n    args[_key9 - 3] = arguments[_key9];\n  }\n\n  if (el.removeEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.removeEventListener.apply(el, [name, handler].concat(args));\n  } else if (el.detachEvent) {\n    // IE 8 及更早 IE 版本\n    el.detachEvent.apply(el, [\"on\".concat(name), handler].concat(args));\n  }\n}\nfunction onDOMMany(els, names, handler) {\n  els = toArrayIfNot(els);\n  names = toArrayIfNot(names);\n\n  for (var _len8 = arguments.length, args = new Array(_len8 > 3 ? _len8 - 3 : 0), _key10 = 3; _key10 < _len8; _key10++) {\n    args[_key10 - 3] = arguments[_key10];\n  }\n\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = els[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var el = _step6.value;\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = names[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var name = _step9.value;\n          onDOM.apply(void 0, [el, name, handler].concat(args));\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n            _iterator9[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n        _iterator6[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  var destroy = function destroy() {\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = els[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var el = _step7.value;\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = names[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var name = _step8.value;\n            offDOM(el, name, handler);\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n              _iterator8[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n          _iterator7[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n  };\n\n  return destroy;\n}\nfunction getImageSizeByUrl(url) {\n  var image = document.createElement('img');\n  return new Promise(function (resolve, reject) {\n    onDOM(image, 'load', function () {\n      resolve({\n        width: image.width,\n        height: image.height\n      });\n    });\n    onDOM(image, 'error', function (e) {\n      reject(e);\n    });\n    image.src = url;\n  });\n}\nfunction findNodeList(list, callback) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var iterator = iterateALL(list, {\n    reverse: opt.reverse\n  });\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = iterator[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var _step10$value = _step10.value,\n          value = _step10$value.value,\n          index = _step10$value.index;\n\n      if (callback(value, index)) {\n        return value;\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10[\"return\"] != null) {\n        _iterator10[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\nfunction findNodeListReverse(list, callback) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opt.reverse = true;\n  return findNodeList(list, callback, opt);\n}\nfunction elementsFromPoint() {\n  var func = document.elementsFromPoint || document.msElementsFromPoint || elementsFromPoint;\n\n  for (var _len9 = arguments.length, args = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {\n    args[_key11] = arguments[_key11];\n  }\n\n  return func.apply(document, args);\n\n  function elementsFromPoint(x, y) {\n    var parents = [];\n    var parent = void 0;\n\n    do {\n      if (parent !== document.elementFromPoint(x, y)) {\n        parent = document.elementFromPoint(x, y);\n        parents.push(parent);\n        parent.style.pointerEvents = 'none';\n      } else {\n        parent = false;\n      }\n    } while (parent);\n\n    parents.forEach(function (parent) {\n      return parent.style.pointerEvents = 'all';\n    });\n    return parents;\n  }\n}\nfunction getOuterAttachedHeight(el) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = _objectSpread2({\n    margin: true,\n    border: true\n  }, opt);\n  var stl = getComputedStyle(el);\n  var r = 0;\n  var arr = [];\n\n  if (opt.margin) {\n    arr.push('margin-top', 'margin-bottom');\n  }\n\n  if (opt.border) {\n    arr.push('border-top-width', 'border-bottom-width');\n  }\n\n  arr.forEach(function (key) {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n}\nfunction getOuterAttachedWidth(el) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = _objectSpread2({\n    margin: true,\n    border: true\n  }, opt);\n  var stl = getComputedStyle(el);\n  var r = 0;\n  var arr = [];\n\n  if (opt.margin) {\n    arr.push('margin-left', 'margin-right');\n  }\n\n  if (opt.border) {\n    arr.push('border-left-width', 'border-right-width');\n  }\n\n  arr.forEach(function (key) {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n} // DOM structure\n\nfunction insertBefore(el, target) {\n  target.parentElement.insertBefore(el, target);\n}\nfunction insertAfter(el, target) {\n  target.parentElement.insertBefore(el, target.nextSibling);\n}\nfunction prependTo(el, target) {\n  target.insertBefore(el, target.firstChild);\n}\nfunction appendTo(el, target) {\n  target.appendChild(el);\n} // advance\n// binarySearch 二分查找\n// callback(mid, i) should return mid - your_value\n\nfunction binarySearch(arr, callback, start, end, returnNearestIfNoHit) {\n  var max = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1000;\n  var midNum;\n  var mid;\n\n  if (start == null) {\n    start = 0;\n    end = arr.length - 1;\n  }\n\n  var i = 0;\n  var r;\n\n  while (start >= 0 && start <= end) {\n    if (i >= max) {\n      throw Error(\"binarySearch: loop times is over \".concat(max, \", you can increase the limit.\"));\n    }\n\n    midNum = Math.floor((end - start) / 2 + start);\n    mid = arr[midNum];\n    r = callback(mid, i);\n\n    if (r > 0) {\n      end = midNum - 1;\n    } else if (r < 0) {\n      start = midNum + 1;\n    } else {\n      return {\n        index: midNum,\n        value: mid,\n        count: i + 1,\n        hit: true\n      };\n    }\n\n    i++;\n  }\n\n  return returnNearestIfNoHit ? {\n    index: midNum,\n    value: mid,\n    count: i + 1,\n    hit: false,\n    bigger: r > 0\n  } : null;\n} //\n\nfunction windowLoaded() {\n  return new Promise(function (resolve, reject) {\n    if (document && document.readyState === 'complete') {\n      resolve();\n    } else {\n      glb().addEventListener('load', function once() {\n        resolve();\n        glb().removeEventListener('load', once);\n      });\n    }\n  });\n}\nfunction waitTime(milliseconds, callback) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      callback && callback();\n      resolve();\n    }, milliseconds);\n  });\n} // overload waitFor(condition, time = 100, maxCount = 1000))\n\nfunction waitFor(name, condition) {\n  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var maxCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n\n  if (isFunction(name)) {\n    maxCount = time;\n    time = isNumeric(condition) ? condition : 100;\n    condition = name;\n    name = null;\n  }\n\n  if (!store.waitFor) store.waitFor = {};\n  var waits = store.waitFor;\n\n  if (name && isset(waits[name])) {\n    glb().clearInterval(waits[name]);\n    delete waits[name];\n  }\n\n  return new Promise(function (resolve, reject) {\n    var count = 0;\n\n    function judge(interval) {\n      if (count <= maxCount) {\n        if (condition()) {\n          stop(interval, name);\n          resolve();\n        }\n      } else {\n        stop(interval, name);\n        reject(new Error('waitFor: Limit is reached'));\n      }\n\n      count++;\n    }\n\n    function stop(interval, name) {\n      if (interval) {\n        if (name && isset(waits[name])) {\n          glb().clearInterval(waits[name]);\n          delete waits[name];\n        } else {\n          glb().clearInterval(interval);\n        }\n      }\n    }\n\n    var interval = glb().setInterval(function () {\n      judge(interval);\n    }, time);\n\n    if (name) {\n      waits[name] = interval;\n    }\n\n    judge();\n  });\n}\nfunction retry(func) {\n  var limitTimes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  if (!store.retry) store.retry = {};\n  var counters = retry;\n  var name = generateName();\n  counters[name] = 0;\n  return doFunc;\n\n  function doFunc(arg1, arg2, arg3) {\n    return func(arg1, arg2, arg3).then(function (data) {\n      delete counters[name];\n      return data;\n    })[\"catch\"](function (e) {\n      counters[name]++;\n\n      if (counters[name] >= limitTimes) {\n        delete counters[name];\n        return Promise.reject(e);\n      } else {\n        return doFunc(arg1, arg2, arg3);\n      }\n    });\n  }\n\n  function generateName() {\n    var name = Math.random() + '';\n\n    if (counters[name]) {\n      return generateName();\n    } else {\n      return name;\n    }\n  }\n} // 复制文字到剪贴板\n\nfunction copyTextToClipboard(text) {\n  try {\n    // use latest api\n    navigator.clipboard.writeText(text);\n    return;\n  } catch (e) {}\n\n  var textArea = document.createElement('textarea'); //\n  // *** This styling is an extra step which is likely not required. ***\n  //\n  // Why is it here? To ensure:\n  // 1. the element is able to have focus and selection.\n  // 2. if element was to flash render it has minimal visual impact.\n  // 3. less flakyness with selection and copying which **might** occur if\n  //    the textarea element is not visible.\n  //\n  // The likelihood is the element won't even render, not even a flash,\n  // so some of these are just precautions. However in IE the element\n  // is visible whilst the popup box asking the user for permission for\n  // the web page to copy to the clipboard.\n  //\n  // Place in top-left corner of screen regardless of scroll position.\n\n  textArea.style.position = 'fixed';\n  textArea.style.top = 0;\n  textArea.style.left = 0; // Ensure it has a small width and height. Setting to 1px / 1em\n  // doesn't work as this gives a negative w/h on some browsers.\n\n  textArea.style.width = '2em';\n  textArea.style.height = '2em'; // We don't need padding, reducing the size if it does flash render.\n\n  textArea.style.padding = 0; // Clean up any borders.\n\n  textArea.style.border = 'none';\n  textArea.style.outline = 'none';\n  textArea.style.boxShadow = 'none'; // Avoid flash of white box if rendered for any reason.\n\n  textArea.style.background = 'transparent';\n  textArea.value = text;\n  document.body.appendChild(textArea);\n  textArea.select();\n\n  try {\n    var successful = document.execCommand('copy');\n    var msg = successful ? 'successful' : 'unsuccessful';\n    console.log('Copying text command was ' + msg);\n  } catch (err) {\n    console.log('Oops, unable to copy');\n  }\n\n  document.body.removeChild(textArea);\n} // jquery\n\nfunction jqFixedSize(sel) {\n  var $ = glb().jQuery;\n  $(sel).each(function () {\n    var t = $(this);\n    t.css({\n      width: t.width() + 'px',\n      height: t.height() + 'px'\n    });\n  });\n}\nfunction jqMakeCarousel(wrapperSel, listSel, itemSel) {\n  var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n  var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 16;\n  var dir = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';\n  var top = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  if (space.toString().match(/^\\d+$/)) {\n    space = space + 'px';\n  }\n\n  var spaceNumber = parseFloat(space);\n  var $ = glb().jQuery;\n  var wrapper = $(wrapperSel);\n  var list = wrapper.find(listSel);\n  wrapper.css({\n    position: 'relative',\n    height: wrapper.height() + 'px'\n  });\n  var items0 = list.find(itemSel);\n  items0.css({\n    margin: '0',\n    marginRight: space\n  });\n  var width = (Math.ceil(items0.width()) + spaceNumber) * items0.length;\n  list.css({\n    position: 'absolute',\n    margin: '0',\n    width: width + 'px'\n  });\n  var height = list.height();\n  var list2 = list.clone();\n  var list3 = list.clone();\n  list.css({\n    left: 0\n  });\n  list2.css({\n    left: width + 'px'\n  });\n  list3.css({\n    left: width * 2 + 'px'\n  });\n  var lists = $('<div></div>');\n  lists.css({\n    position: 'absolute',\n    width: width * 3 + 'px',\n    height: height + 'px',\n    left: 0,\n    top: top\n  });\n  lists.append(list).append(list2).append(list3);\n  wrapper.append(lists);\n  var left = 0;\n\n  function animateLoop() {\n    if (dir === 'left') {\n      left -= 100;\n    } else {\n      left += 100;\n    }\n\n    lists.animate({\n      left: \"\".concat(left, \"px\")\n    }, speed, 'linear', function () {\n      if (Math.abs(left) > width) {\n        if (dir === 'left') {\n          left += width;\n        } else {\n          left -= width;\n        }\n\n        lists.css({\n          left: left + 'px'\n        });\n      }\n\n      animateLoop();\n    });\n  }\n\n  animateLoop();\n} // https://developer.mozilla.org/docs/Web/API/Window/open\n// http://www.w3school.com.cn/htmldom/met_win_open.asp#windowfeatures\n\nfunction openWindow(url, name) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  glb().open(url, name, Object.keys(opt).map(function (k) {\n    return \"\".concat(k, \"=\").concat(opt[k]);\n  }).join(','));\n}\nfunction openCenterWindow(url, name, width, height) {\n  var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var t = {\n    width: width,\n    height: height,\n    top: (glb().screen.availHeight - 30 - height) / 2,\n    left: (glb().screen.availWidth - 30 - width) / 2\n  };\n  Object.assign(t, opt);\n  openWindow(url, name, t);\n}\nvar URLHelper =\n/*#__PURE__*/\nfunction () {\n  // protocol, hostname, port, pastname\n  function URLHelper(baseUrl) {\n    var _this3 = this;\n\n    _classCallCheck(this, URLHelper);\n\n    this.baseUrl = '';\n    this.search = {};\n    var t = decodeURI(baseUrl).split('?');\n    this.baseUrl = t[0];\n\n    if (t[1]) {\n      t[1].split('&').forEach(function (v) {\n        var t2 = v.split('=');\n        _this3.search[t2[0]] = t2[1] == null ? '' : decodeURIComponent(t2[1]);\n      });\n    }\n  }\n\n  _createClass(URLHelper, [{\n    key: \"getHref\",\n    value: function getHref() {\n      var _this4 = this;\n\n      var t = [this.baseUrl];\n      var searchStr = Object.keys(this.search).map(function (k) {\n        return \"\".concat(k, \"=\").concat(encodeURIComponent(_this4.search[k]));\n      }).join('&');\n\n      if (searchStr) {\n        t.push(searchStr);\n      }\n\n      return t.join('?');\n    }\n  }]);\n\n  return URLHelper;\n}(); // 解析函数参数, 帮助重载\n// types eg: ['Object', (i) => i > 3, ['Number', default], null ]\n// null represent all types of argument\n\nfunction resolveArgsByType(args, types) {\n  var argIndex = 0;\n  return types.map(function (v) {\n    // make rule\n    var rule, dft;\n\n    if (isArray(v)) {\n      rule = v[0];\n      dft = v[1];\n    } else {\n      rule = v;\n      dft = undefined;\n    }\n\n    if (!isFunction(rule)) {\n      if (rule == null) {\n        rule = function rule() {\n          return true;\n        };\n      } else {\n        var t = rule;\n\n        rule = function rule(x) {\n          return Object.prototype.toString.call(x) === \"[object \".concat(t, \"]\");\n        };\n      }\n    }\n\n    var arg = args[argIndex];\n\n    if (rule(arg)) {\n      argIndex++;\n      return arg;\n    } else {\n      return dft;\n    }\n  });\n} // set null can remove a item\n\nfunction makeStorageHelper(storage) {\n  return {\n    storage: storage,\n    set: function set(name, value, minutes) {\n      if (value == null) {\n        this.storage.removeItem(name);\n      } else {\n        this.storage.setItem(name, JSON.stringify({\n          value: value,\n          expired_at: minutes ? new Date().getTime() + minutes * 60 * 1000 : null\n        }));\n      }\n    },\n    get: function get(name) {\n      var t = this.storage.getItem(name);\n\n      if (t) {\n        t = JSON.parse(t);\n\n        if (!t.expired_at || t.expired_at > new Date().getTime()) {\n          return t.value;\n        } else {\n          this.storage.removeItem(name);\n        }\n      }\n\n      return null;\n    },\n    clear: function clear() {\n      this.storage.clear();\n    }\n  };\n}\nfunction getLocalStorage2() {\n  if (!store.localStorage2) {\n    store.localStorage2 = makeStorageHelper(glb().localStorage);\n  }\n\n  return store.localStorage2;\n}\nfunction getSessionStorage2() {\n  if (!store.sessionStorage2) {\n    store.sessionStorage2 = makeStorageHelper(glb().sessionStorage);\n  }\n\n  return store.sessionStorage2;\n} // 事件处理\n\nvar EventProcessor =\n/*#__PURE__*/\nfunction () {\n  function EventProcessor() {\n    _classCallCheck(this, EventProcessor);\n\n    this.eventStore = [];\n  }\n\n  _createClass(EventProcessor, [{\n    key: \"on\",\n    value: function on(name, handler) {\n      this.eventStore.push({\n        name: name,\n        handler: handler\n      });\n    }\n  }, {\n    key: \"once\",\n    value: function once(name, handler) {\n      var _this5 = this;\n\n      var off = function off() {\n        _this5.off(name, wrappedHandler);\n      };\n\n      var wrappedHandler = function wrappedHandler() {\n        handler.apply(void 0, arguments);\n        off();\n      };\n\n      this.on(name, wrappedHandler);\n      return off;\n    }\n  }, {\n    key: \"onceTimeout\",\n    value: function onceTimeout(name, handler, timeout) {\n      var _this6 = this;\n\n      var off;\n      var promise = new Promise(function (resolve, reject) {\n        var wrappedHandler = function wrappedHandler() {\n          handler.apply(void 0, arguments);\n          resolve();\n        };\n\n        off = _this6.once(name, wrappedHandler);\n        waitTime(timeout).then(function () {\n          off();\n          reject();\n        });\n      });\n\n      var off2 = function off2() {\n        off && off();\n      };\n\n      return {\n        off: off2,\n        promise: promise\n      };\n    }\n  }, {\n    key: \"off\",\n    value: function off(name, handler) {\n      var indexes = []; // to remove indexes; reverse; 倒序的\n\n      var len = this.eventStore.length;\n\n      for (var i = 0; i < len; i++) {\n        var item = this.eventStore[i];\n\n        if (item.name === name && item.handler === handler) {\n          indexes.unshift(i);\n        }\n      }\n\n      for (var _i11 = 0, _indexes = indexes; _i11 < _indexes.length; _i11++) {\n        var index = _indexes[_i11];\n        this.eventStore.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(name) {\n      // 重要: 先找到要执行的项放在新数组里, 因为执行项会改变事件项存储数组\n      var items = [];\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = this.eventStore[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var item = _step11.value;\n\n          if (item.name === name) {\n            items.push(item);\n          }\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11[\"return\"] != null) {\n            _iterator11[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key12 = 1; _key12 < _len10; _key12++) {\n        args[_key12 - 1] = arguments[_key12];\n      }\n\n      for (var _i12 = 0, _items = items; _i12 < _items.length; _i12++) {\n        var _item = _items[_i12];\n\n        _item.handler.apply(_item, args);\n      }\n    }\n  }]);\n\n  return EventProcessor;\n}();\nvar CrossWindowEventProcessor =\n/*#__PURE__*/\nfunction (_EventProcessor) {\n  _inherits(CrossWindowEventProcessor, _EventProcessor);\n\n  // id\n  function CrossWindowEventProcessor(opt) {\n    var _this7;\n\n    _classCallCheck(this, CrossWindowEventProcessor);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(CrossWindowEventProcessor).call(this));\n    _this7.storageName = '_crossWindow';\n    _this7.windows = [];\n    _this7.timeout = 200;\n    _this7.BROADCAST = '__BROADCAST__';\n\n    if (opt) {\n      Object.assign(_assertThisInitialized(_this7), opt);\n    }\n\n    onDOM(window, 'storage', function (ev) {\n      if (ev.key === _this7.storageName) {\n        var event = JSON.parse(ev.newValue);\n\n        if (!event.targets || event.targets.includes(_this7.id)) {\n          var _this8;\n\n          (_this8 = _this7).emitLocal.apply(_this8, [event.name].concat(_toConsumableArray(event.args)));\n        }\n      }\n    }); // social parts 集体部分\n    // join\n\n    _this7.id = strRand();\n    _this7.windows = [_this7.id];\n    _this7.ready = new Promise(function (resolve, reject) {\n      _this7.onceTimeout('_windows_updated', function (_ref) {\n        var windows = _ref.windows;\n        _this7.windows = windows;\n      }, _this7.timeout).promise.then(function () {\n        resolve(); // responsed 被响应\n      }, function () {\n        // no response 无响应\n        resolve();\n      });\n\n      _this7.broadcast('_join', _this7.id);\n    });\n\n    _this7.ready.then(function () {\n      // on join\n      _this7.on('_join', function (id) {\n        _this7.windows.push(id);\n\n        if (_this7.isMain()) {\n          _this7.broadcast('_windows_updated', {\n            windows: _this7.windows,\n            type: 'join',\n            id: id\n          });\n        }\n      }); // on _windows_updated\n\n\n      _this7.on('_windows_updated', function (_ref2) {\n        var windows = _ref2.windows;\n        _this7.windows = windows;\n      }); // on exit\n\n\n      _this7.on('_exit', function (id) {\n        var oldMain = _this7.windows[0];\n        arrayRemove(_this7.windows, id);\n\n        if (_this7.isMain()) {\n          _this7.emit('_windows_updated', {\n            windows: _this7.windows,\n            type: 'exit',\n            id: id\n          });\n\n          if (oldMain != _this7.id) {\n            console.log('_main_updated');\n\n            _this7.emit('_main_updated', {\n              windows: _this7.windows,\n              old: oldMain,\n              'new': _this7.id\n            });\n          }\n        }\n      });\n\n      onDOM(window, 'beforeunload', function () {\n        _this7.exitGroup();\n      });\n    });\n\n    return _this7;\n  }\n\n  _createClass(CrossWindowEventProcessor, [{\n    key: \"isMain\",\n    value: function isMain() {\n      return this.id === this.windows[0];\n    }\n  }, {\n    key: \"emitTo\",\n    value: function emitTo(name, targets) {\n      for (var _len11 = arguments.length, args = new Array(_len11 > 2 ? _len11 - 2 : 0), _key13 = 2; _key13 < _len11; _key13++) {\n        args[_key13 - 2] = arguments[_key13];\n      }\n\n      if (targets === this.BROADCAST) {\n        targets = null;\n      } else {\n        if (targets && !isArray(targets)) {\n          targets = [targets];\n        }\n\n        if (targets.includes(this.id)) {\n          var _get2;\n\n          (_get2 = _get(_getPrototypeOf(CrossWindowEventProcessor.prototype), \"emit\", this)).call.apply(_get2, [this, name].concat(args)); // emit to current window\n\n        }\n      }\n\n      glb().localStorage.setItem(this.storageName, JSON.stringify({\n        name: name,\n        targets: targets,\n        args: args,\n        // use random make storage event triggered every time\n        // 加入随机保证触发storage事件\n        random: Math.random()\n      }));\n    }\n  }, {\n    key: \"emitLocal\",\n    value: function emitLocal(name) {\n      for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key14 = 1; _key14 < _len12; _key14++) {\n        args[_key14 - 1] = arguments[_key14];\n      }\n\n      this.emitTo.apply(this, [name, this.id].concat(args));\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(name) {\n      for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key15 = 1; _key15 < _len13; _key15++) {\n        args[_key15 - 1] = arguments[_key15];\n      }\n\n      this.emitTo.apply(this, [name, this.BROADCAST].concat(args));\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(name) {\n      for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key16 = 1; _key16 < _len14; _key16++) {\n        args[_key16 - 1] = arguments[_key16];\n      }\n\n      this.emitTo.apply(this, [name, this.windows].concat(args));\n    }\n  }, {\n    key: \"exitGroup\",\n    value: function exitGroup() {\n      this.broadcast('_exit', this.id);\n    }\n  }]);\n\n  return CrossWindowEventProcessor;\n}(EventProcessor); // Deprecated in next version\n\nvar CrossWindow = CrossWindowEventProcessor;\nfunction onQuickKeydown(handler) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = _objectSpread2({\n    timeout: 1000\n  }, opt);\n  var input = '';\n  var timeoutId;\n\n  var keydownHandler = function keydownHandler(e) {\n    if (e.key && e.key.length === 1) {\n      input = \"\".concat(input).concat(e.key);\n      handler(input);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n\n      setTimeout(function () {\n        input = '';\n      }, opt.timeout);\n    }\n  };\n\n  onDOM(document, 'keydown', keydownHandler);\n  return function () {\n    offDOM(document, 'keydown', keydownHandler);\n  };\n}\nfunction getUserLanguage() {\n  return navigator.language || navigator.userLanguage;\n}\nvar Cache =\n/*#__PURE__*/\nfunction () {\n  function Cache() {\n    _classCallCheck(this, Cache);\n\n    this.store = {};\n  }\n\n  _createClass(Cache, [{\n    key: \"has\",\n    value: function has(name) {\n      return this.store.hasOwnProperty(name);\n    }\n  }, {\n    key: \"remember\",\n    value: function remember(name, getter) {\n      if (!this.has(name)) {\n        this.store[name] = {\n          value: getter()\n        };\n      }\n\n      return this.store[name].value;\n    }\n  }, {\n    key: \"forget\",\n    value: function forget(name) {\n      if (name) {\n        if (this.has(name)) {\n          delete this.store[name];\n        }\n      } else {\n        this.store = {};\n      }\n    }\n  }]);\n\n  return Cache;\n}(); // attach cached getters to an object; can attach to self\n\nfunction attachCache(obj, toCache) {\n  var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Cache();\n\n  var _loop4 = function _loop4(key) {\n    var getter = toCache[key];\n    Object.defineProperty(obj, key, {\n      get: function get() {\n        var _this9 = this;\n\n        return cache.remember(key, function () {\n          return getter.call(_this9);\n        });\n      }\n    });\n  };\n\n  for (var key in toCache) {\n    _loop4(key);\n  }\n}\n\nexport { Cache, CrossWindow, CrossWindowEventProcessor, EventProcessor, URLHelper, addClass, appendTo, arrayAt, arrayDiff, arrayDistinct, arrayFirst, arrayGet, arrayLast, arrayRemove, arrayRemoveBySortedIndexes, arraySibling, arrayWithoutEnd, assignIfDifferent, attachCache, backupAttr, binarySearch, camelCase, camelToWords, cloneObj, copyTextToClipboard, debounce, debounceImmediate, debounceTrailing, elementsFromPoint, empty, executeOnceInScopeByName, executePromiseGetters, executeWithCount, findNodeList, findNodeListReverse, findParent, forAll, getBorder, getBoundingClientRect, getCss3Prefix, getElSize, getElSizeEvenInvisible, getImageSizeByUrl, getLocalStorage2, getOffset, getOffsetParent, getOuterAttachedHeight, getOuterAttachedWidth, getPosition, getPositionFromOffset, getScroll, getSessionStorage2, getUrlParam, getUserLanguage, getViewportPosition, glb, groupArray, hasClass, insertAfter, insertBefore, isArray, isBool, isDescendantOf, isFunction, isNumber, isNumeric, isObject, isOffsetInEl, isPromise, isString, isset, iterateALL, joinFunctionsByNext, joinFunctionsByResult, joinMethods, jqFixedSize, jqMakeCarousel, kebabCase, makeStorageHelper, mapObjectTree, mapObjects, max, min, newArrayRemoveAt, numPad, numRand, objectExcept, objectGet, objectMap, objectMerge, objectOnly, objectSet, offDOM, offsetToViewportPosition, onDOM, onDOMMany, onQuickKeydown, openCenterWindow, openWindow, pairRows, prependTo, promiseTimeout, removeClass, removeEl, replaceMultiple, resolveArgsByType, resolveValueOrGettter, restoreAttr, retry, setElChildByIndex, snakeCase, splitArray, store, store_executeOnceInScopeByName, strRand, studlyCase, titleCase, toArrayIfNot, uniqueId, unset, viewportPositionToOffset, waitFor, waitTime, watchChange, windowLoaded };\n","import * as hp from 'helper-js'\r\n\r\n/**\r\n * [updatablePropsEvenUnbound description]\r\n * @param  {[type]} props [un-circular object or getter]\r\n * @return {[type]}       [description]\r\n * props eg: {\r\n    value: {localName: 'current'},\r\n  }\r\n   default localName is `localProps_${name}`\r\n */\r\nexport function updatablePropsEvenUnbound(props) {\r\n  if (hp.isFunction(props)) {\r\n    props = props()\r\n  } else if(hp.isArray(props)) {\r\n    props = props.slice()\r\n  } else {\r\n    // object\r\n    props = Object.assign({}, props)\r\n  }\r\n  const component = {\r\n    props,\r\n    computed: {},\r\n    watch: {},\r\n  }\r\n  let propNames\r\n  const localNames = {}\r\n  if (hp.isArray(props)) {\r\n    propNames = props\r\n  } else {\r\n    propNames = []\r\n    for (const key in props) {\r\n      propNames.push(key)\r\n      if (props[key].localName) {\r\n        localNames[key] = props[key].localName\r\n        delete props[key].localName\r\n      }\r\n    }\r\n  }\r\n  component.data = function () {\r\n    const t = {\r\n      localValueOfUpdatableProps: {},\r\n    }\r\n    for (const name of propNames) {\r\n      t.localValueOfUpdatableProps[name] = this[name]\r\n    }\r\n    return t\r\n  }\r\n  for (const name of propNames) {\r\n    component.watch[name] = function (value) {\r\n      this.localValueOfUpdatableProps[name] = value\r\n    }\r\n    const localName = localNames[name] || `localProps_${name}`\r\n    component.computed[localName] = {\r\n      get(){ return this.localValueOfUpdatableProps[name] },\r\n      set(value) {\r\n        if (name === 'value') {\r\n          this.$emit('input', value)\r\n        } else {\r\n          this.$emit(`update:${name}`, value)\r\n        }\r\n        this.localValueOfUpdatableProps[name] = value\r\n      },\r\n    }\r\n  }\r\n  return component\r\n}\r\n\r\nexport function isPropTrue(value) {\r\n  return value === '' || value\r\n}\r\n\r\n// the dependences in getter can't be auto resolved. must use exec to include dependences\r\nexport function watchAsync(vm, getter, handler, opt) {\r\n  let destroies = []\r\n  let value, oldValue\r\n  let count = -1 // updated count\r\n  main()\r\n  return destroy\r\n  function destroy() {\r\n    destroies.forEach(f => f())\r\n    destroies = []\r\n  }\r\n  function exec(getter, opt) {\r\n    let value\r\n    let first = true\r\n    const unwatch = vm.$watch(() => getter.call(vm, exec), value2 => {\r\n      value = value2\r\n      if (first) {\r\n        first = false\r\n      } else {\r\n        main()\r\n      }\r\n    }, {immediate: true, deep: opt && opt.deep})\r\n    destroies.push(unwatch)\r\n    return value\r\n  }\r\n  function main() {\r\n    destroy()\r\n    const result = getter.call(vm, exec)\r\n    count++\r\n    const localCount = count\r\n    oldValue = value\r\n    const getterExecuted = (value) => {\r\n      if (localCount !== count) {\r\n        // expired\r\n        return\r\n      }\r\n      if (localCount === 0) {\r\n        if (opt && opt.immediate) {\r\n          handler.call(vm, value, oldValue)\r\n        }\r\n      } else {\r\n        handler.call(vm, value, oldValue)\r\n      }\r\n    }\r\n    //\r\n    if (hp.isPromise(result)) {\r\n      result.then(getterExecuted)\r\n    } else {\r\n      getterExecuted(result)\r\n    }\r\n  }\r\n}\r\n// do handler first, handler return getter\r\nexport function doWatch(vm, handler) {\r\n  let oldValue, unwatch\r\n  const update = () => {\r\n    const getter = handler.call(vm, oldValue)\r\n    unwatch = vm.$watch(getter, (value) => {\r\n      unwatch()\r\n      oldValue = value\r\n      update()\r\n    })\r\n  }\r\n  update()\r\n  return () => unwatch && unwatch()\r\n}\r\n\r\nexport function* iterateObjectWithoutDollarDash(obj) {\r\n  for (const key in obj) {\r\n    const start = key.substr(0, 1)\r\n    if (start !== '$' && start !== '_') {\r\n      yield {key, value: obj[key]}\r\n    }\r\n  }\r\n}\r\n\r\n// add reactive `windowSize`\r\nexport const windowSize = {\r\n  data() {\r\n    return {\r\n      windowSize: {\r\n        innerWidth: window.innerWidth,\r\n        innerHeight: window.innerHeight,\r\n        outerWidth: window.outerWidth,\r\n        outerHeight: window.outerHeight,\r\n      },\r\n    }\r\n  },\r\n  methods: {\r\n    updateWindowSize() {\r\n      Object.assign(this.windowSize, {\r\n        innerWidth: window.innerWidth,\r\n        innerHeight: window.innerHeight,\r\n        outerWidth: window.outerWidth,\r\n        outerHeight: window.outerHeight,\r\n      })\r\n    },\r\n  },\r\n  created() {\r\n    this._windowSize_onresize = () => {\r\n      this.updateWindowSize()\r\n      this.$emit('window-resize')\r\n    }\r\n    hp.onDOM(window, 'resize', this._windowSize_onresize)\r\n  },\r\n  beforeDestroy() {\r\n    hp.offDOM(window, 'resize', this._windowSize_onresize)\r\n  },\r\n}\r\n\r\nexport function registerPreventURLChange(Vue, router, msg) {\r\n  let preventRouter = false\r\n  const msg0 = `It looks like you have been editing something.\r\nIf you leave before saving, your changes will be lost.`\r\n  router.beforeEach((to, from, next) => {\r\n    if (preventRouter) {\r\n      if (window.confirm(msg || msg0)) {\r\n        Vue.allowURLChange()\r\n        next()\r\n      } else {\r\n        next(false)\r\n      }\r\n    } else {\r\n      next()\r\n    }\r\n  })\r\n  const beforeunload = (e) => {\r\n    var confirmationMessage = msg || msg0\r\n    e.returnValue = confirmationMessage;     // Gecko, Trident, Chrome 34+\r\n    return confirmationMessage;              // Gecko, WebKit, Chrome <34\r\n  }\r\n  Vue.preventURLChange = Vue.prototype.$preventURLChange = (msg2) => {\r\n    if (msg2 != null) {\r\n      msg = msg2\r\n    }\r\n    if (!preventRouter) {\r\n      preventRouter = true\r\n      window.addEventListener(\"beforeunload\", beforeunload)\r\n    }\r\n  }\r\n  Vue.allowURLChange = Vue.prototype.$allowURLChange = () => {\r\n    preventRouter = false\r\n    window.removeEventListener(\"beforeunload\", beforeunload)\r\n  }\r\n}\r\n"],"names":["isArray","v","Object","prototype","toString","call","iterateObjectWithoutDollarDash","obj","key","start","substr","value","windowSize","data","innerWidth","window","innerHeight","outerWidth","outerHeight","methods","updateWindowSize","assign","this","created","_windowSize_onresize","_this","$emit","el","name","handler","_len6","arguments","length","args","Array","_key8","addEventListener","apply","concat","attachEvent","hp","beforeDestroy","_len7","_key9","removeEventListener","detachEvent","vm","oldValue","unwatch","update","getter","$watch","Vue","router","msg","preventRouter","msg0","beforeEach","to","from","next","confirm","allowURLChange","beforeunload","e","confirmationMessage","returnValue","preventURLChange","$preventURLChange","msg2","$allowURLChange","props","propNames","component","slice","computed","watch","localNames","push","localName","t","localValueOfUpdatableProps","get","set","opt","destroies","count","main","destroy","forEach","f","exec","first","value2","immediate","deep","result","localCount","getterExecuted","then"],"mappings":";;;;;0MAwNA,SAASA,EAAQC,SAC8B,mBAAtCC,OAAOC,UAAUC,SAASC,KAAKJ,iCC9EvBK,GAAV,SAAUA,EAA+BC,wHAC5BA,mDAAPC,aAEK,OADRC,EAAQD,EAAIE,OAAO,EAAG,KACG,MAAVD,kCACb,CAACD,IAAAA,EAAKG,MAAOJ,EAAIC,qEAMhBI,EAAa,CACxBC,sBACS,CACLD,WAAY,CACVE,WAAYC,OAAOD,WACnBE,YAAaD,OAAOC,YACpBC,WAAYF,OAAOE,WACnBC,YAAaH,OAAOG,eAI1BC,QAAS,CACPC,4BACElB,OAAOmB,OAAOC,KAAKV,WAAY,CAC7BE,WAAYC,OAAOD,WACnBE,YAAaD,OAAOC,YACpBC,WAAYF,OAAOE,WACnBC,YAAaH,OAAOG,gBAI1BK,mCACOC,qBAAuB,WAC1BC,EAAKL,mBACLK,EAAKC,MAAM,kBDqhDjB,SAAeC,EAAIC,EAAMC,OAClB,IAAIC,EAAQC,UAAUC,OAAQC,EAAO,IAAIC,MAAMJ,EAAQ,EAAIA,EAAQ,EAAI,GAAIK,EAAQ,EAAGA,EAAQL,EAAOK,IACxGF,EAAKE,EAAQ,GAAKJ,UAAUI,GAG1BR,EAAGS,iBAELT,EAAGS,iBAAiBC,MAAMV,EAAI,CAACC,EAAMC,GAASS,OAAOL,IAC5CN,EAAGY,aAEZZ,EAAGY,YAAYF,MAAMV,EAAI,CAAC,KAAKW,OAAOV,GAAOC,GAASS,OAAOL,IC7hD7DO,CAASzB,OAAQ,SAAUO,KAAKE,uBAElCiB,0BD8hDF,SAAgBd,EAAIC,EAAMC,OACnB,IAAIa,EAAQX,UAAUC,OAAQC,EAAO,IAAIC,MAAMQ,EAAQ,EAAIA,EAAQ,EAAI,GAAIC,EAAQ,EAAGA,EAAQD,EAAOC,IACxGV,EAAKU,EAAQ,GAAKZ,UAAUY,GAG1BhB,EAAGiB,oBAELjB,EAAGiB,oBAAoBP,MAAMV,EAAI,CAACC,EAAMC,GAASS,OAAOL,IAC/CN,EAAGkB,aAEZlB,EAAGkB,YAAYR,MAAMV,EAAI,CAAC,KAAKW,OAAOV,GAAOC,GAASS,OAAOL,ICviD7DO,CAAUzB,OAAQ,SAAUO,KAAKE,kCArD9B,SAAiBsB,EAAIjB,OACtBkB,EAAUC,SACC,SAATC,QACEC,EAASrB,EAAQxB,KAAKyC,EAAIC,GAChCC,EAAUF,EAAGK,OAAOD,GAAQ,SAACvC,GAC3BqC,IACAD,EAAWpC,EACXsC,OAGJA,GACO,kBAAMD,GAAWA,mBApEnB,SAAoBrC,SACR,KAAVA,GAAgBA,iEAiHlB,SAAkCyC,EAAKC,EAAQC,OAChDC,GAAgB,EACdC,2GAENH,EAAOI,YAAW,SAACC,EAAIC,EAAMC,GACvBL,EACExC,OAAO8C,QAAQP,GAAOE,IACxBJ,EAAIU,iBACJF,KAEAA,GAAK,GAGPA,WAGEG,EAAe,SAACC,OAChBC,EAAsBX,GAAOE,SACjCQ,EAAEE,YAAcD,EACTA,GAETb,EAAIe,iBAAmBf,EAAIjD,UAAUiE,kBAAoB,SAACC,GAC5C,MAARA,IACFf,EAAMe,GAEHd,IACHA,GAAgB,EAChBxC,OAAOqB,iBAAiB,eAAgB2B,KAG5CX,EAAIU,eAAiBV,EAAIjD,UAAUmE,gBAAkB,WACnDf,GAAgB,EAChBxC,OAAO6B,oBAAoB,eAAgBmB,iCA3MxC,SAAmCQ,GD+N1C,ICjNMC,EALEC,EAAY,CAChBF,MARAA,ED8NkB,mBC/NFA,EACRA,IACA/B,EAAW+B,GACXA,EAAMG,QAGNxE,OAAOmB,OAAO,GAAIkD,GAI1BI,SAAU,GACVC,MAAO,IAGHC,EAAa,MACfrC,EAAW+B,GACbC,EAAYD,WAGP,IAAM/D,KADXgE,EAAY,GACMD,EAChBC,EAAUM,KAAKtE,GACX+D,EAAM/D,GAAKuE,YACbF,EAAWrE,GAAO+D,EAAM/D,GAAKuE,iBACtBR,EAAM/D,GAAKuE,WAIxBN,EAAU5D,KAAO,eACTmE,EAAI,CACRC,2BAA4B,uCAEXT,iDAAW,KAAnB5C,UACToD,EAAEC,2BAA2BrD,GAAQN,KAAKM,6FAErCoD,yDAEEpD,UACT6C,EAAUG,MAAMhD,GAAQ,SAAUjB,QAC3BsE,2BAA2BrD,GAAQjB,OAEpCoE,EAAYF,EAAWjD,yBAAuBA,GACpD6C,EAAUE,SAASI,GAAa,CAC9BG,sBAAc5D,KAAK2D,2BAA2BrD,IAC9CuD,aAAIxE,GACW,UAATiB,OACGF,MAAM,QAASf,QAEfe,uBAAgBE,GAAQjB,QAE1BsE,2BAA2BrD,GAAQjB,OAb3B6D,8IAiBZC,gBAQF,SAAoB3B,EAAII,EAAQrB,EAASuD,OAE1CzE,EAAOoC,EADPsC,EAAY,GAEZC,GAAS,SACbC,IACOC,WACEA,IACPH,EAAUI,SAAQ,SAAAC,UAAKA,OACvBL,EAAY,YAELM,EAAKzC,EAAQkC,OAChBzE,EACAiF,GAAQ,EACN5C,EAAUF,EAAGK,QAAO,kBAAMD,EAAO7C,KAAKyC,EAAI6C,MAAO,SAAAE,GACrDlF,EAAQkF,EACJD,EACFA,GAAQ,EAERL,MAED,CAACO,WAAW,EAAMC,KAAMX,GAAOA,EAAIW,cACtCV,EAAUP,KAAK9B,GACRrC,WAEA4E,IACPC,QACMQ,EAAS9C,EAAO7C,KAAKyC,EAAI6C,GAEzBM,IADNX,EAEAvC,EAAWpC,MDuIIV,ECtITiG,EAAiB,SAACvF,GAClBsF,IAAeX,IAIA,IAAfW,EACEb,GAAOA,EAAIU,WACbjE,EAAQxB,KAAKyC,EAAInC,EAAOoC,GAG1BlB,EAAQxB,KAAKyC,EAAInC,EAAOoC,KD4Hb9C,ECxHE+F,EDyH0B,qBAAtC9F,OAAOC,UAAUC,SAASC,KAAKJ,GCxHlC+F,EAAOG,KAAKD,GAEZA,EAAeF"}