{"version":3,"file":"tree-helper.min.js","sources":["../src/index.js"],"sourcesContent":["import * as hp from 'helper-js'\n\nexport function clone(obj, childrenKey = 'children') {\n  let cloned\n  if (hp.isArray(obj)) {\n    cloned = obj.map(item => clone(item))\n  } else {\n    cloned = Object.assign({}, obj)\n    if (cloned[childrenKey]) {\n      cloned[childrenKey] = clone(cloned[childrenKey])\n    }\n  }\n  return cloned\n}\n\n// 旧版深度优先遍历\n// old Depth-First-Search\nexport function forIn(obj, handler, childrenKey = 'children') {\n  var rootChildren, rootParent, func\n  if (hp.isArray(obj)) {\n    rootChildren = obj\n    rootParent = null\n  } else {\n    rootChildren = [obj]\n    rootParent = null\n  }\n  if (rootChildren) {\n    func = function(children, parent) {\n      for (const key in children) {\n        const child = children[key]\n        if (handler(child, key, parent) === false) {\n          return false\n        }\n        if (child[childrenKey] != null) {\n          if (func(child[childrenKey], child) === false) {\n            return false\n          }\n        }\n      }\n      return true\n    }\n    func(rootChildren, rootParent)\n  }\n  return obj\n}\n\n// 深度优先遍历\n// Depth-First-Search\nexport function depthFirstSearch(obj, handler, childrenKey = 'children', reverse) {\n  const rootChildren = hp.isArray(obj) ? obj : [obj]\n  //\n  const StopException = () => {}\n  const func = (children, parent) => {\n    if (reverse) {\n      children = children.slice()\n      children.reverse()\n    }\n    const len = children.length\n    for (let i = 0; i < len; i++) {\n      const item = children[i]\n      const r = handler(item, i, parent)\n      if (r === false) {\n        // stop\n        throw new StopException()\n      } else if (r === 'skip children') {\n        continue\n      } else if (r === 'skip siblings') {\n        break\n      }\n      if (item[childrenKey] != null) {\n        func(item[childrenKey], item)\n      }\n    }\n  }\n  try {\n    func(rootChildren)\n  } catch (e) {\n    if (e instanceof StopException) {\n     // stop\n   } else {\n     throw e\n   }\n  }\n}\n\n// 广度优先遍历\n// Breadth-First-Search\nexport function breadthFirstSearch(obj, handler, childrenKey = 'children', reverse) {\n  const rootChildren = hp.isArray(obj) ? obj : [obj]\n  //\n  let stack = rootChildren.map((v, i) => ({item: v, index: i}))\n  if (reverse) {\n    stack.reverse()\n  }\n  while (stack.length) {\n    const {item, index, parent} = stack.shift()\n    const r = handler(item, index, parent)\n    if (r === false) {\n      // stop\n      return\n    } else if (r === 'skip children') {\n      continue\n    } else if (r === 'skip siblings') {\n      stack = stack.filter(v => v.parent !== parent)\n    }\n    if (item.children) {\n      let children = item.children\n      if (reverse) {\n        children = children.slice()\n        children.reverse()\n      }\n      const pushStack = children.map((v, i) => ({item: v, index: i, parent: item}))\n      stack.push(...pushStack)\n    }\n  }\n}\n\nfunction _changeParent(item, parent, childrenKey = 'children', parentKey = 'parent') {\n  // remove item from original list\n  if (item[parentKey]) {\n    hp.arrayRemove(item[parentKey][childrenKey], item)\n  }\n  item[parentKey] = parent\n}\n\nexport function getTreeDataFromFlat(data, idKey, parentIdKey) {\n  data.forEach(item => (item.children = data.filter(v => v[parentIdKey] === item[idKey])))\n  return data.filter(item => item[parentIdKey] == null)\n}\nexport function insertBefore(item, target, childrenKey = 'children', parentKey = 'parent') {\n  if (item === target) {\n    return\n  }\n  const siblings = target[parentKey][childrenKey]\n  let index = siblings.indexOf(target)\n  if (siblings[index - 1] !== item) {\n    if (item[parentKey] === target[parentKey]) {\n      hp.arrayRemove(siblings, item)\n      index = siblings.indexOf(target)\n    } else {\n      _changeParent(item, target[parentKey])\n    }\n    siblings.splice(index, 0, item)\n  }\n}\nexport function insertAfter(item, target, childrenKey = 'children', parentKey = 'parent') {\n  if (item === target) {\n    return\n  }\n  const targetParent = target[parentKey]\n  const siblings = targetParent[childrenKey]\n  let index = siblings.indexOf(target)\n  if (siblings[index + 1] !== item) {\n    if (item[parentKey] === target[parentKey]) {\n      hp.arrayRemove(siblings, item)\n      index = siblings.indexOf(target)\n    } else {\n      _changeParent(item, target[parentKey])\n    }\n    siblings.splice(index + 1, 0, item)\n  }\n}\nexport function prependTo(item, target, childrenKey = 'children', parentKey = 'parent') {\n  if (item === target) {\n    throw `can't prepend to self`\n  }\n  const targetChildren = target[childrenKey]\n  if (targetChildren[0] !== item) {\n    _changeParent(item, target)\n    targetChildren.splice(0, 0, item)\n  }\n}\nexport function appendTo(item, target, childrenKey = 'children', parentKey = 'parent') {\n  if (item === target) {\n    throw `can't append to self`\n  }\n  const targetChildren = target[childrenKey]\n  const targetChildrenLast = targetChildren[ targetChildren.length - 1 ]\n  if (targetChildrenLast !== item) {\n    _changeParent(item, target)\n    targetChildren.push(item)\n  }\n}\n"],"names":["_changeParent","item","parent","childrenKey","parentKey","hp","target","targetChildren","length","push","obj","handler","reverse","stack","map","v","i","index","shift","r","filter","children","slice","pushStack","clone","cloned","Object","assign","rootChildren","StopException","func","len","e","rootParent","key","child","data","idKey","parentIdKey","forEach","siblings","indexOf","splice"],"mappings":"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"}